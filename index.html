<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4×4盤おにぎり</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap');

        body {
            margin: 0;
            padding: 0;
            font-family: 'Noto Sans JP', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
            color: white;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 100;
            display: flex;
            flex-direction: column;
            padding: 2vh 2vw;
            gap: 2vh;
        }
        
        .ui-element {
            pointer-events: auto;
        }
        
        .ui-top-row {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 2vw;
        }
        
        .ui-left-section {
            display: flex;
            flex-direction: column;
            gap: 2vh;
        }
        
        #scorePanel {
            background: rgba(0, 0, 0, 0.8);
            padding: 2vh 2vw;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            font-size: clamp(12px, 2.5vw, 16px);
            min-width: clamp(120px, 20vw, 140px);
        }
        
        #moveHistory {
            background: rgba(0, 0, 0, 0.8);
            padding: 2vh 2vw;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            width: clamp(120px, 20vw, 150px);
            max-height: 25vh;
            overflow-y: auto;
            font-size: clamp(11px, 2.2vw, 15px);
        }
        
        #moveList {
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.4;
        }
        
        .move-entry {
            margin: 3px 0;
            display: flex;
            align-items: center;
        }
        
        .move-number {
            color: #888;
            margin-right: 10px;
            width: 25px;
            flex-shrink: 0;
        }
        
        .move-notation {
            color: #fff;
            margin-right: 8px;
        }
        
        .move-player {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            margin-left: 8px;
            flex-shrink: 0;
        }
        
        .move-player.black {
            background: #333;
            border: 1px solid #fff;
        }
        
        .move-player.white {
            background: #fff;
            border: 1px solid #333;
        }
        
        #controls {
            display: flex;
            flex-direction: column;
            gap: 1.5vh;
        }
        
        .btn {
            padding: clamp(8px, 1.5vh, 12px) clamp(12px, 2vw, 20px);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            color: white;
            cursor: pointer;
            font-size: clamp(11px, 2.2vw, 15px);
            font-weight: bold;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            min-width: clamp(60px, 12vw, 80px);
        }
        
        .btn:hover {
            background: rgba(0, 0, 0, 1.2);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-1px);
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        #message {
            position: fixed;
            bottom: 8vh;
            left: 50%;
            transform: translateX(-50%);
            font-size: clamp(14px, 3vw, 20px);
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            text-align: center;
            color: #ffffff;
            z-index: 150;
        }
        
        #gameOverModal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }
        
        .modal-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            border: 2px solid rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(20px);
        }
        
        .score-display {
            display: flex;
            align-items: center;
            margin: 10px 0;
            font-size: 16px;
        }
        
        .player-icon {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 10px;
            display: inline-block;
        }
        
        .black-icon {
            background: #333;
            border: 2px solid #fff;
        }
        
        .white-icon {
            background: #fff;
            border: 2px solid #333;
        }
        
        #centerMessage {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(24px, 6vw, 40px);
            font-weight: bold;
            text-shadow: 4px 4px 8px rgba(0, 0, 0, 0.8), 2px 2px 4px rgba(0, 0, 0, 0.6), 0 0 20px rgba(255, 255, 255, 0.5);
            text-align: center;
            z-index: 150;
            color: #ffffff;
            display: none;
            background: rgba(0, 0, 0, 0.7);
            padding: clamp(8px, 2vh, 12px) clamp(16px, 3vw, 24px);
            border-radius: 15px;
        }

        #titleScreen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            color: white;
        }
        
        .title-content {
            text-align: center;
            padding: 40px;
            border-radius: 15px;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(20px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            max-width: 600px;
            margin: 20px;
        }
        
        .title-content h1 {
            font-size: clamp(30px, 8vw, 60px);
            margin: 0 0 30px 0;
            color: #ffffff;
            text-shadow: 4px 4px 8px rgba(0, 0, 0, 0.5);
            font-weight: bold;
        }
        
        .title-content p {
            font-size: clamp(16px, 3vw, 20px);
            line-height: 1.6;
            margin: 0 0 40px 0;
            color: #ffffff;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .start-btn {
            padding: 20px 40px;
            font-size: clamp(18px, 4vw, 24px);
            font-weight: bold;
            background: rgba(255, 255, 255, 0.2);
            border: 3px solid rgba(255, 255, 255, 0.5);
            border-radius: 15px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            font-family: 'Noto Sans JP', sans-serif;
        }
        
        .start-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.8);
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
        }

        @media (max-width: 2000px) {
            #ui {
                padding: 12px;
                gap: 12px;
            }
            
            #scorePanel {
                padding: 20px;
                font-size: 18px;
                min-width: 160px;
            }
            
            #moveHistory {
                min-width: 160px;
                max-height: 220px;
                padding: 20px;
                font-size: 13px;
            }
            
            #moveList {
                font-size: 12px;
            }
            
            #controls {
                top: 12px;
                right: 12px;
                gap: 10px;
            }
            
            .btn {
                padding: 30px 60px;
                font-size: 18px;
                min-width: 90px;
            }
            
            #message {
                bottom: 25px;
                font-size: 25px;
            }
            
            #centerMessage {
                font-size: 32px;
                padding: 10px 20px;
            }
        }

        @media (max-width: 768px) {
            #ui {
                padding: 1.5vh 1.5vw;
                gap: 1.5vh;
            }
        
            .btn {
                padding: 17px 40px;
                font-size: 10px;
                min-width: 70px;
            }
            
            .ui-top-row {
                flex-direction: row;
                justify-content: space-between;
                align-items: flex-start;
                gap: 1.5vw;
            }
            
            .ui-left-section {
                flex-direction: row;
                gap: 1.5vw;
            }
            
            #scorePanel {
                padding: 1.5vh 1.5vw;
                flex: 0 0 auto;
                max-height: 100px;
                font-size: clamp(10px, 2.2vw, 12px);
                min-width: clamp(80px, 18vw, 90px);
            }
            
            #moveHistory {
                padding: 1.5vh 1.5vw;
                font-size: clamp(9px, 2vw, 11px);
                width: clamp(100px, 25vw, 120px);
                max-height: 20vh;
            }
            
            #message {
                bottom: 12vh;
                font-size: clamp(12px, 2.8vw, 16px);
            }

            .title-content {
                padding: 30px 20px;
                margin: 10px;
            }
            
            .title-content h1 {
                margin-bottom: 20px;
            }
            
            .title-content p {
                margin-bottom: 30px;
            }
            
            .start-btn {
                padding: 15px 30px;
            }
        }

        @media (max-width: 500px) {
            #ui {
                padding: 1vh 1vw;
                gap: 1vh;
            }
            
            .ui-top-row {
                display: flex;
                flex-direction: row;
                align-items: flex-start;
                gap: 1vw;
            }
            
            .ui-left-section {
                display: flex;
                flex-direction: row;
                gap: 1vw;
                flex: 1;
            }
            
            #scorePanel {
                flex: 0 0 140px;
                max-height: 100px;
                padding: 1vh 1vw;
                font-size: 8px;
                display: flex;
                flex-direction: column;
                gap: 0.8px;
                line-height: 1;
                overflow: hidden;
            }
        
            #scorePanel .score-row {
                display: flex;
                align-items: center;
                gap: 0.8px;
                white-space: nowrap;
            }
            
            #scorePanel .score-row img {
                width: 16px;
                height: 16px;
                object-fit: contain;
                max-height: 100px;
            }
            
            #moveHistory {
                flex: 1 1 auto;
                min-width: 80px;
                margin-right: 0px;
                padding: 1vh 1vw;
                font-size: clamp(8px, 1.8vw, 10px);
                max-height: 100px;
                overflow-y: auto;
            }
            
            #controls {
                flex: 0 0 auto;
            }
            
            #message {
                bottom: 10vh;
                font-size: clamp(18px, 2.5vw, 20px);
            }

            .title-content {
                padding: 20px 15px;
            }
            
            .title-content p {
                font-size: 14px;
                margin-bottom: 25px;
            }
        }
        
        @media (max-width: 768px) and (orientation: landscape) {
            #ui {
                padding: 1vh 1vw;
                gap: 1vh;
            }
            
            .ui-top-row {
                gap: 1vw;
            }
            
            .ui-left-section {
                gap: 1vw;
            }
            
            #moveHistory {
                max-height: 15vh;
            }
            
            #message {
                bottom: 8vh;
                font-size: clamp(12px, 2.5vw, 16px);
            }
        }
        
        @media (max-width: 450px) {
            #ui {
                padding: 0.8vh 0.8vw;
                gap: 0.8vh;
            }
            
            .ui-top-row {
                gap: 0.8vw;
            }
            
            .ui-left-section {
                gap: 0.8vw;
            }
            
            #scorePanel {
                padding: 0.8vh 0.8vw;
                font-size: clamp(8px, 1.8vw, 10px);
                min-width: clamp(60px, 14vw, 70px);
                max-height: 100px;
            }
            
            #moveHistory {
                padding: 0.8vh 0.8vw;
                font-size: clamp(7px, 1.6vw, 9px);
                width: clamp(60px, 14vw, 70px);
                max-height: 15vh;
                max-height: 100px;
            }
            
            #message {
                bottom: 8vh;
                font-size: clamp(15px, 2vw, 20px);
            }
        }
    </style>
</head>
<body>
    <div id="titleScreen">
        <div class="title-content">
            <h1>ようこそ</h1>
            <p>これは4×4盤のオセロです。<br>
            4×4盤では後手が必勝法を持っているため、<br>
            必勝プログラムを作りました。<br>
            あなたが先手、プログラム(おにぎり)が後手です。<br>
            <br>
            楽しんでいただければ幸いです。</p>
            <button id="startGameBtn" class="start-btn">はじめる</button>
        </div>
    </div>
    <div id="gameContainer">
        <div id="ui">
            <div class="ui-top-row">
                <div class="ui-left-section">
                    <div id="scorePanel" class="ui-element">
                        <h3 style="margin: 0 0 12px 0; color: #ffffff; font-size: 1.1em;">4×4盤おにぎり</h3>
                        <div class="score-display">
                            <span class="player-icon black-icon"></span>
                            <span>あなた: <span id="playerScore">2</span></span>
                        </div>
                        <div class="score-display">
                            <span class="player-icon white-icon"></span>
                            <span>おにぎり: <span id="aiScore">2</span></span>
                        </div>
                    </div>

                    <div id="moveHistory" class="ui-element">
                        <h4 style="margin: 0 0 10px 0; color: #ffffff; font-size: 1em;">棋譜</h4>
                        <div id="moveList"></div>
                    </div>
                </div>

                <div id="controls" class="ui-element">
                    <button id="undoBtn" class="btn">待った</button>
                    <button id="resetBtn" class="btn">リセット</button>
                </div>
            </div>
        </div>

        <div id="message"></div>
        
        <div id="centerMessage"></div>

        <div id="gameOverModal">
            <div class="modal-content">
                <h2 id="gameResult"></h2>
                <div style="margin: 20px 0;">
                    <div class="score-display" style="justify-content: center;">
                        <span class="player-icon black-icon"></span>
                        <span>あなた: <span id="finalPlayerScore"></span></span>
                    </div>
                    <div class="score-display" style="justify-content: center;">
                        <span class="player-icon white-icon"></span>
                        <span>おにぎり: <span id="finalAiScore"></span></span>
                    </div>
                </div>
                <button class="btn" onclick="startNewGame()">もう一度プレイ</button>
            </div>
        </div>
    </div>

    <script>
        let scene, camera, renderer, raycaster, mouse;
        let board = [];
        let gameState = 'waiting';
        let currentPlayer = 0;
        let moveHistory = [];
        let boardPieces = [];
        let validMovesHighlights = [];
        let isAnimating = false;
        let lastMoveHighlight = null;
        let initialAnimationDone = false;
        let gameNotation = []; 
        let isGameEnding = false; 
        let validMovesVisible = false;

        const node = [19,27,1,8,26,11,11,25,26,26,0,8,16,24,25,25,11,11,11,11,-1,-1,24,24,1,2,3,1,3,8,1,2,16,24,24,2,0,8,3,-1,-1,-1,1,3,-1,1,0,8,0,24,2,1,-1,-1,-1,-1,3,8,8,8];
        let changed_node = [...node];
        let white_node = 1;

        const louds_data_string = '101010111010101010101111010101010101010101010111011010101010101010101000101010101010101010101010101001001010100101010100000';
        const louds_data = louds_data_string.split('').map(c => parseInt(c));

        function positionToNotation(x, y) {
            const columns = ['a', 'b', 'c', 'd'];
            const rows = ['1', '2', '3', '4'];
            return columns[x] + rows[y];
        }

        function setButtonsEnabled(enabled) {
            document.getElementById('undoBtn').disabled = !enabled;
            document.getElementById('resetBtn').disabled = !enabled;
        }

        function updateMoveHistoryDisplay() {
            const moveList = document.getElementById('moveList');
            let html = '';

            let actualMoveNumber = 1;
            let currentTurn = 0; 
            
            for (let i = 0; i < moveHistory.length; i++) {
                const move = moveHistory[i];

                if (move.x !== -1) {
                    const notation = positionToNotation(move.x, move.y);
                    const isPlayerMove = move.color === 1;
                    
                    html += '<div class="move-entry">';
                    html += '<span class="move-number">' + actualMoveNumber + '.</span>';
                    html += '<span class="move-notation">' + notation + '</span>';
                    html += '<span class="move-player ' + (isPlayerMove ? 'black' : 'white') + '"></span>';
                    html += '</div>';
                    
                    actualMoveNumber++;
                }
            }
            
            moveList.innerHTML = html;

            const moveHistoryElement = document.getElementById('moveHistory');
            moveHistoryElement.scrollTop = moveHistoryElement.scrollHeight;
        }

        function adjustCameraForScreenSize() {
            const aspect = window.innerWidth / window.innerHeight;
            const width = window.innerWidth;
            
            if (width <= 450) {
                camera.position.set(0, 9.4, 6.5);
                camera.fov = 68;
                camera.lookAt(0, 0, 0);
            } else if (width <= 500) {
                camera.position.set(0, 9.4, 6.5);
                camera.fov = 65;
                camera.lookAt(0, 0, 0);
            } else if (width <= 768) {
                camera.position.set(0, 8, 6);
                camera.fov = 62;
                camera.lookAt(0, 0, 0);
            } else if (width <= 1024) {
                camera.position.set(0, 6.2, 4.1);
                camera.fov = 60;
                camera.lookAt(0, 0, 0);
            } else {
                camera.position.set(0, 6, 4);
                camera.fov = 60;
                camera.lookAt(0, 0, 0);
            }
            
            camera.updateProjectionMatrix();
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x6fa8dc);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            adjustCameraForScreenSize();

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('gameContainer').appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(-10, 10, -5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            createBoard();
            createCoordinateLabels();

            renderer.domElement.addEventListener('click', onBoardClick);
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                renderer.setSize(window.innerWidth, window.innerHeight);
                adjustCameraForScreenSize(); 
            });
            window.addEventListener('orientationchange', onWindowResize);
            
            document.getElementById('undoBtn').addEventListener('click', undoMove);
            document.getElementById('resetBtn').addEventListener('click', startNewGame);

            animate();
        }

        function createBoard() {
            const boardGeometry = new THREE.BoxGeometry(5, 0.3, 5);
            const boardMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
            const boardMesh = new THREE.Mesh(boardGeometry, boardMaterial);
            boardMesh.receiveShadow = true;
            scene.add(boardMesh);

            for (let i = 0; i <= 4; i++) {
                const vLineGeometry = new THREE.BoxGeometry(0.02, 0.31, 5);
                const vLineMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
                const vLine = new THREE.Mesh(vLineGeometry, vLineMaterial);
                vLine.position.set(-2.5 + i * 1.25, 0.15, 0);
                scene.add(vLine);

                const hLineGeometry = new THREE.BoxGeometry(5, 0.31, 0.02);
                const hLineMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
                const hLine = new THREE.Mesh(hLineGeometry, hLineMaterial);
                hLine.position.set(0, 0.15, -2.5 + i * 1.25);
                scene.add(hLine);
            }
        }

        function createCoordinateLabels() {
            const columns = ['a', 'b', 'c', 'd'];
            columns.forEach((col, index) => {
                const geometry = new THREE.PlaneGeometry(0.4, 0.4);
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const context = canvas.getContext('2d');
                context.fillStyle = 'black';
                context.font = '60px Arial';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(col, 32, 32);
                
                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.MeshLambertMaterial({ map: texture, transparent: true });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(-1.875 + index * 1.25, 0.2, -3.2);
                mesh.rotation.x = -Math.PI / 2;
                mesh.userData = { isCoordinateLabel: true };
                scene.add(mesh);
            });

            const rows = ['1', '2', '3', '4'];
            rows.forEach((row, index) => {
                const geometry = new THREE.PlaneGeometry(0.4, 0.4);
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const context = canvas.getContext('2d');
                context.fillStyle = 'black';
                context.font = '60px Arial';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(row, 32, 32);
                
                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.MeshLambertMaterial({ map: texture, transparent: true });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(-3.2, 0.2, -1.875 + index * 1.25);
                mesh.rotation.x = -Math.PI / 2;
                mesh.userData = { isCoordinateLabel: true };
                scene.add(mesh);
            });
        }

        function animateInitialPieces(callback) {
            if (isAnimating && initialAnimationDone) {
                return;
            }

            boardPieces.forEach(piece => scene.remove(piece));
            boardPieces = [];

            const initialPositions = [
                {x: 1, y: 1, color: 2}, 
                {x: 2, y: 1, color: 1}, 
                {x: 1, y: 2, color: 1}, 
                {x: 2, y: 2, color: 2}   
            ];
        
            let placedPieces = 0;
            const totalPieces = initialPositions.length;
            let callbackExecuted = false; 
            
            initialPositions.forEach((pos, index) => {
                setTimeout(() => {
                    if (callbackExecuted) return;
                    
                    dropPieceWithBounce(pos.x, pos.y, pos.color, () => {
                        placedPieces++;
                        if (placedPieces === totalPieces && !callbackExecuted) {
                            callbackExecuted = true;
                            setTimeout(() => {
                                if (callback && typeof callback === 'function') {
                                    callback();
                                }
                            }, 200);
                        }
                    });
                }, index * 300);
            });
        }

        function createPieceGeometry() {
            const cylinder = new THREE.CylinderGeometry(0.4, 0.4, 0.2, 32);
            
            const colors = [];
            const positions = cylinder.attributes.position.array;
            
            for (let i = 0; i < positions.length; i += 3) {
                const y = positions[i + 1];
                
                if (y > 0) {
                    colors.push(0.2, 0.2, 0.2);
                } else {
                    colors.push(1.0, 1.0, 1.0);
                }
            }
            
            cylinder.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            return cylinder;
        }

        function initializeGame() {
            board = [];
            for (let y = 0; y < 4; y++) {
                board[y] = [];
                for (let x = 0; x < 4; x++) {
                    board[y][x] = 0; 
                }
            }
        
            gameState = 'playing';
            currentPlayer = 0;
            moveHistory = [];
            gameNotation = [];
            white_node = 1;
            changed_node = [...node];
            isAnimating = false;
            validMovesVisible = false;

            if (lastMoveHighlight) {
                scene.remove(lastMoveHighlight);
                lastMoveHighlight = null;
            }

            hideValidMoves();

            updateMoveHistoryDisplay();

            if (!initialAnimationDone) {
                initialAnimationDone = true;
                setButtonsEnabled(false);
                animateInitialPieces(() => {
                    board[1][1] = 2;
                    board[1][2] = 1;
                    board[2][1] = 1;
                    board[2][2] = 2;
                    
                    updateScore();
                    updateMessage("あなたの番です");
                    
                    setTimeout(() => {
                        showValidMoves();
                    }, 300);
                });
            } else {
                board[1][1] = 2;
                board[1][2] = 1;
                board[2][1] = 1;
                board[2][2] = 2;
                
                updateBoard();
                updateScore();
                updateMessage("あなたの番です");
                showValidMoves();
            }
        }

        function replayBoard() {
            for (let y = 0; y < 4; y++) {
                for (let x = 0; x < 4; x++) {
                    board[y][x] = 0;
                }
            }
            
            board[1][1] = 2;
            board[1][2] = 1;
            board[2][1] = 1;
            board[2][2] = 2;
            
            let space = 12;
            let tekazu = 0;
            let current_turn = 0;
            white_node = 1;
            changed_node = [...node];

            gameNotation = [];
            
            for (let i = 0; i < moveHistory.length; i++) {
                const move = moveHistory[i];
                
                if (move.x === -1) {
                    tekazu += 1;
                    current_turn = 1 - current_turn;
                } else {
                    const y = move.y;
                    const x = move.x;
                    const color = move.color;
                    
                    board[y][x] = color;
                    flipPieces(x, y, color, false);
                    space -= 1;
                    tekazu += 1;

                    gameNotation.push(positionToNotation(x, y));
                    
                    if (color === 1) {
                        applyNodeTransformation(y * 4 + x);
                    }
                    
                    if (color === 2) {
                        let prev_move = -1;
                        for (let j = i - 1; j >= 0; j--) {
                            if (moveHistory[j].color === 1 && moveHistory[j].x !== -1) {
                                prev_move = moveHistory[j].y * 4 + moveHistory[j].x;
                                break;
                            }
                        }
                        
                        if (prev_move !== -1) {
                            const result = onigiri_move(white_node, prev_move);
                            if (result.next_node !== -1) {
                                white_node = result.next_node;
                            }
                        }
                    }
                    
                    current_turn = 1 - current_turn;
                }
            }
            
            currentPlayer = current_turn;
            updateMoveHistoryDisplay();
        }

        function updateBoard() {
            boardPieces.forEach(piece => scene.remove(piece));
            boardPieces = [];

            for (let y = 0; y < 4; y++) {
                for (let x = 0; x < 4; x++) {
                    if (board[y][x] !== 0) {
                        createPiece(x, y, board[y][x]);
                    }
                }
            }
        }

        function createPiece(x, y, color) {
            const geometry = createPieceGeometry();
            const material = new THREE.MeshLambertMaterial({ 
                vertexColors: true
            });
            const piece = new THREE.Mesh(geometry, material);
            
            piece.position.set(
                -1.875 + x * 1.25,
                0.25,
                -1.875 + y * 1.25
            );
            
            if (color === 2) {
                piece.rotation.x = Math.PI;
            }
            
            piece.castShadow = true;
            scene.add(piece);
            boardPieces.push(piece);
        }

        function onBoardClick(event) {
            if (gameState !== 'playing' || currentPlayer !== 0 || isAnimating || !validMovesVisible) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            const boardPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            const intersectPoint = new THREE.Vector3();
            raycaster.ray.intersectPlane(boardPlane, intersectPoint);

            const x = Math.floor((intersectPoint.x + 2.5) / 1.25);
            const z = Math.floor((intersectPoint.z + 2.5) / 1.25);

            if (x >= 0 && x < 4 && z >= 0 && z < 4) {
                makeMove(x, z, 1);
            }
        }

        function makeMove(x, y, color) {
            if (!isValidMove(x, y, color) || isAnimating) return false;

            isAnimating = true;
            setButtonsEnabled(false);
            const flipped = flipPieces(x, y, color, true);
            if (flipped.length === 0) {
                isAnimating = false;
                document.getElementById('resetBtn').disabled = false;
                return false;
            }

            fadeOutValidMoves(() => {
                board[y][x] = color;
                moveHistory.push({ x, y, color, flipped: [...flipped] });

                gameNotation.push(positionToNotation(x, y));
                updateMoveHistoryDisplay();

                if (color === 1) {
                    applyNodeTransformation(y * 4 + x);
                }

                if (lastMoveHighlight) {
                    scene.remove(lastMoveHighlight);
                    lastMoveHighlight = null;
                }

                showLastMoveHighlight(x, y);

                updateBoard();

                if (flipped.length > 0) {
                    flipPieces(x, y, color, false);

                    animateFlippedPieces(flipped, () => {
                        updateBoard();
                        updateScore();
                        isAnimating = false;
                        if (color === 1) {
                            const actualPlayerMoves = moveHistory.filter(move => move.color === 1 && move.x !== -1).length;
                            if (actualPlayerMoves >= 1) {
                                setButtonsEnabled(true);
                            }
                        } else {
                            setButtonsEnabled(true);
                        }
                        
                        if (checkGameEnd()) {
                            return;
                        }
                        
                        currentPlayer = 1 - currentPlayer;
                        
                        if (currentPlayer === 1) {
                            updateMessage("おにぎりの番です");
                            setButtonsEnabled(false);
                            setTimeout(() => makeAIMove(), 1000);
                        } else {
                            const playerMoves = getValidMoves(1);
                            if (playerMoves.length === 0) {
                                updateMessage("あなたに有効な手がありません。おにぎりの番です。");
                                currentPlayer = 1;
                                setButtonsEnabled(false);
                                setTimeout(() => makeAIMove(), 1000);
                            } else {
                                updateMessage("あなたの番です");
                                showValidMoves();
                            }
                        }
                    });
                } else {
                    updateScore();
                    isAnimating = false;
                    if (color === 1) {
                        const actualPlayerMoves = moveHistory.filter(move => move.color === 1 && move.x !== -1).length;
                        if (actualPlayerMoves >= 1) {
                            setButtonsEnabled(true);
                        }
                    } else {
                        setButtonsEnabled(true);
                    }
                    
                    currentPlayer = 1 - currentPlayer;
                    
                    if (currentPlayer === 1) {
                        updateMessage("おにぎりの番です");
                        setButtonsEnabled(false); 
                        setTimeout(() => makeAIMove(), 1000);
                    } else {
                        const playerMoves = getValidMoves(1);
                        if (playerMoves.length === 0) {
                            updateMessage("あなたに有効な手がありません。おにぎりの番です。");
                            currentPlayer = 1;
                            setButtonsEnabled(false);
                            setTimeout(() => makeAIMove(), 1000);
                        } else {
                            updateMessage("あなたの番です");
                            showValidMoves();
                        }
                    }
                }
            });
            return true;
        }

        function makeAIMove() {
            if (isAnimating) return;
            
            try {
                let prev_move = -1;
                for (let i = moveHistory.length - 1; i >= 0; i--) {
                    if (moveHistory[i].color === 1 && moveHistory[i].x !== -1) {
                        prev_move = moveHistory[i].y * 4 + moveHistory[i].x;
                        break;
                    }
                }
                
                const aiValidMoves = getValidMoves(2);
                
                if (aiValidMoves.length === 0) {
                    moveHistory.push({ x: -1, y: -1, color: 2, flipped: [] });
                    updateBoard();
                    updateScore();
                    
                    if (checkGameEnd()) {
                        return;
                    }
                    
                    currentPlayer = 0;
                    setButtonsEnabled(false);
                    updateMessage("パス");
                    setTimeout(() => {
                        updateMessage("あなたの番です");
                        setButtonsEnabled(true);
                        showValidMoves();
                    }, 2000);
                    return;
                }
                
                const result = onigiri_move(white_node, prev_move);
                
                if (result.cy >= 0 && result.cy < 4 && result.cx >= 0 && result.cx < 4) {
                    const isValid = isValidMove(result.cx, result.cy, 2);
                    
                    if (isValid) {
                        isAnimating = true;
                        setButtonsEnabled(false);
                        const flipped = flipPieces(result.cx, result.cy, 2, true);
                        board[result.cy][result.cx] = 2;
                        
                        moveHistory.push({ 
                            x: result.cx, 
                            y: result.cy, 
                            color: 2, 
                            flipped: [...flipped] 
                        });

                        gameNotation.push(positionToNotation(result.cx, result.cy));
                        updateMoveHistoryDisplay();
                        
                        if (result.next_node > 0) {
                            white_node = result.next_node;
                        }

                        if (lastMoveHighlight) {
                            scene.remove(lastMoveHighlight);
                            lastMoveHighlight = null;
                        }

                        showLastMoveHighlight(result.cx, result.cy);

                        updateBoard();

                        if (flipped.length > 0) {
                            flipPieces(result.cx, result.cy, 2, false);
                            
                            animateFlippedPieces(flipped, () => {
                                updateBoard();
                                updateScore();
                                isAnimating = false;
                                setButtonsEnabled(true);
                                
                                if (checkGameEnd()) {
                                    return;
                                }
                                
                                const playerMoves = getValidMoves(1);
                                if (playerMoves.length === 0) {
                                    updateMessage("パス");
                                    currentPlayer = 1;
                                    setButtonsEnabled(false); 
                                    setTimeout(() => makeAIMove(), 2000);
                                } else {
                                    currentPlayer = 0;
                                    updateMessage("あなたの番です");
                                    showValidMoves();
                                }
                            });
                        } else {
                            updateScore();
                            isAnimating = false;
                            setButtonsEnabled(true);
                            
                            if (checkGameEnd()) {
                                return;
                            }
                            
                            const playerMoves = getValidMoves(1);
                            if (playerMoves.length === 0) {
                                updateMessage("パス");
                                currentPlayer = 1;
                                setTimeout(() => makeAIMove(), 2000);
                            } else {
                                currentPlayer = 0;
                                updateMessage("あなたの番です");
                                showValidMoves();
                            }
                        }
                    } else {
                        updateMessage("エラー発生");
                        return;
                    }
                } else {
                    updateMessage("エラー発生");
                    return;
                }
                
            } catch (error) {
                updateMessage("エラー発生");
                return;
            }
        }

        function animateFlippedPieces(flippedPositions, callback) {
            let animationsCompleted = 0;
            const totalAnimations = flippedPositions.length;
            
            if (totalAnimations === 0) {
                callback();
                return;
            }

            flippedPositions.forEach((pos, index) => {
                setTimeout(() => {
                    const piece = findPieceAt(pos.x, pos.y);
                    if (piece) {
                        animateFlip(piece, () => {
                            animationsCompleted++;
                            if (animationsCompleted === totalAnimations) {
                                callback();
                            }
                        });
                    } else {
                        animationsCompleted++;
                        if (animationsCompleted === totalAnimations) {
                            callback();
                        }
                    }
                }, index * 50);
            });
        }

        function findPieceAt(x, y) {
            const targetX = -1.875 + x * 1.25;
            const targetZ = -1.875 + y * 1.25;
            
            return boardPieces.find(piece => {
                const dx = Math.abs(piece.position.x - targetX);
                const dz = Math.abs(piece.position.z - targetZ);
                return dx < 0.1 && dz < 0.1;
            });
        }

        function animateFlip(piece, callback) {
            const originalY = piece.position.y;
            const duration = 300;
            const startTime = Date.now();
            const originalRotation = piece.rotation.x;

            let targetRotation;
            if (Math.abs(originalRotation) < 0.1) {
                targetRotation = Math.PI;
            } else {
                targetRotation = 0;
            }

            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                const heightOffset = Math.sin(progress * Math.PI) * 0.5;
                piece.position.y = originalY + heightOffset;
                
                piece.rotation.x = originalRotation + (targetRotation - originalRotation) * progress;

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    piece.position.y = originalY;
                    piece.rotation.x = targetRotation;
                    callback();
                }
            }
            animate();
        }

        function showValidMoves() {
            const moves = getValidMoves(1);
            
            validMovesHighlights.forEach(highlight => scene.remove(highlight));
            validMovesHighlights = [];
            validMovesVisible = false;

            moves.forEach(move => {
                const geometry = new THREE.RingGeometry(0.3, 0.5, 16);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0x00ffff, 
                    transparent: true, 
                    opacity: 0.6 
                });
                const highlight = new THREE.Mesh(geometry, material);
                highlight.position.set(
                    -1.875 + move.x * 1.25,
                    0.16,
                    -1.875 + move.y * 1.25
                );
                highlight.rotation.x = -Math.PI / 2;
                scene.add(highlight);
                validMovesHighlights.push(highlight);
            });
            setTimeout(() => {
                validMovesVisible = true;
            }, 100);
        }

        function hideValidMoves() {
            validMovesHighlights.forEach(highlight => scene.remove(highlight));
            validMovesHighlights = [];
            validMovesVisible = false;
        }

        function showLastMoveHighlight(x, y) {
            const geometry = new THREE.PlaneGeometry(1.25, 1.25);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0xff2020, 
                transparent: true, 
                opacity: 0.5 
            });
            lastMoveHighlight = new THREE.Mesh(geometry, material);
            lastMoveHighlight.position.set(
                -1.875 + x * 1.25,
                0.16,
                -1.875 + y * 1.25
            );
            lastMoveHighlight.rotation.x = -Math.PI / 2;
            scene.add(lastMoveHighlight);
        }

        function fadeOutValidMoves(callback) {
            validMovesVisible = false;

            const duration = 200;
            const startTime = Date.now();
            
            function fade() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const opacity = 0.6 * (1 - progress);
                
                validMovesHighlights.forEach(highlight => {
                    highlight.material.opacity = Math.max(0, opacity);
                });
                
                if (progress < 1) {
                    requestAnimationFrame(fade);
                } else {
                    hideValidMoves();
                    callback();
                }
            }
            fade();
        }

        function select_0(louds_data, n) {
            for (let pos = 0; pos < louds_data.length; pos++) {
                if (louds_data[pos] === 0) {
                    n -= 1;
                    if (n === 0) {
                        return pos + 1;
                    }
                }
            }
            return -1;
        }

        function select_1(louds_data, n) {
            for (let pos = 0; pos < louds_data.length; pos++) {
                if (louds_data[pos] === 1) {
                    n -= 1;
                    if (n === 0) {
                        return pos + 1;
                    }
                }
            }
            return -1;
        }

        function rank_0(louds_data, k) {
            let count = 0;
            for (let i = k; i >= 0; i--) {
                if (i < louds_data.length && louds_data[i] === 0) {
                    count++;
                }
            }
            return count;
        }

        function rank_1(louds_data, k) {
            let count = 0;
            for (let i = k; i >= 0; i--) {
                if (i < louds_data.length && louds_data[i] === 1) {
                    count++;
                }
            }
            return count;
        }

        function find_children_index(louds_data, white_node) {
            const children_index = [];
            const index_0 = select_0(louds_data, white_node);
            
            if (index_0 === -1 || index_0 >= louds_data.length) {
                return [];
            }
            
            if (louds_data[index_0] === 0) {
                return [];
            }

            let i = 0;
            while (index_0 + i < louds_data.length && louds_data[index_0 + i] === 1) {
                children_index.push(index_0 + i);
                i++;
            }

            return children_index;
        }

        function find_children_node(louds_data, children_index) {
            const children_node = [];
            if (children_index.length === 0) {
                return [];
            }
            
            for (let i = 0; i < children_index.length; i++) {
                children_node.push(rank_1(louds_data, children_index[i]));
            }
            return children_node;
        }

        function find_black_node(children_node, place) {
            for (let i = 0; i < children_node.length; i++) {
                const nodeIndex = children_node[i] - 2;
                if (changed_node.length > nodeIndex && nodeIndex >= 0 && 
                    changed_node[nodeIndex] === place) {
                    return children_node[i];
                }
            }
            return -1;
        }

        function next_white_node(louds_data, black_node) {
            const select0Result = select_0(louds_data, black_node);
            if (select0Result === -1) {
                return -1;
            }
            return rank_1(louds_data, select0Result);
        }

        function onigiri_move(white_node, place) {
            try {
                const children_index = find_children_index(louds_data, white_node);
                const children_node = find_children_node(louds_data, children_index);
                
                if (children_node.length === 0) {
                    return { cy: -1, cx: -1, next_node: -1 };
                }
                
                const firstChildIndex = children_node[0] - 2;
                let black_node;
                
                if (changed_node.length > firstChildIndex && firstChildIndex >= 0 &&
                    changed_node[firstChildIndex] === -1) {
                    black_node = children_node[0];
                } else {
                    black_node = find_black_node(children_node, place);
                    
                    if (black_node === -1) {
                        return { cy: -1, cx: -1, next_node: -1 };
                    }
                }
                
                const next_node = next_white_node(louds_data, black_node);
                
                if (next_node === -1) {
                    return { cy: -1, cx: -1, next_node: -1 };
                }
                
                const nextNodeIndex = next_node - 2;
                
                if (!(changed_node.length > nextNodeIndex && nextNodeIndex >= 0)) {
                    return { cy: -1, cx: -1, next_node: -1 };
                }
                
                const targetPosition = changed_node[nextNodeIndex];
                
                if (targetPosition < 0 || targetPosition >= 16) {
                    return { cy: -1, cx: -1, next_node: -1 };
                }
                
                const cy = Math.floor(targetPosition / 4);
                const cx = targetPosition % 4;
                
                return { 
                    cy: cy, 
                    cx: cx, 
                    next_node: next_node
                };
                
            } catch (error) {
                return { cy: -1, cx: -1, next_node: -1 };
            }
        }

        function applyNodeTransformation(move) {
            if (white_node === 1) {
                if (move === 11) {
                    for (let i = 0; i < changed_node.length; i++) {
                        if (7 < changed_node[i] && changed_node[i] < 12) {
                            changed_node[i] = changed_node[i] - 4;
                        } else if (15 < changed_node[i] && changed_node[i] < 20) {
                            changed_node[i] = changed_node[i] - 8;
                        } else if (23 < changed_node[i] && changed_node[i] < 28) {
                            changed_node[i] = changed_node[i] - 12;
                        }
                    }
                } else if (move === 14) {
                    for (let i = 0; i < changed_node.length; i++) {
                        if (-1 < changed_node[i] && changed_node[i] < 4) {
                            changed_node[i] = 4 * changed_node[i];
                        } else if (7 < changed_node[i] && changed_node[i] < 12) {
                            changed_node[i] = 4 * changed_node[i] - 31;
                        } else if (15 < changed_node[i] && changed_node[i] < 20) {
                            changed_node[i] = 4 * changed_node[i] - 62;
                        } else if (23 < changed_node[i] && changed_node[i] < 28) {
                            changed_node[i] = 4 * changed_node[i] - 93;
                        }
                    }
                } else if (move === 4) {
                    for (let i = 0; i < changed_node.length; i++) {
                        if (-1 < changed_node[i] && changed_node[i] < 4) {
                            changed_node[i] = 15 - changed_node[i];
                        } else if (7 < changed_node[i] && changed_node[i] < 12) {
                            changed_node[i] = 19 - changed_node[i];
                        } else if (15 < changed_node[i] && changed_node[i] < 20) {
                            changed_node[i] = 23 - changed_node[i];
                        } else if (23 < changed_node[i] && changed_node[i] < 28) {
                            changed_node[i] = 27 - changed_node[i];
                        }
                    }
                } else if (move === 1) {
                    for (let i = 0; i < changed_node.length; i++) {
                        if (-1 < changed_node[i] && changed_node[i] < 4) {
                            changed_node[i] = 15 - 4 * changed_node[i];
                        } else if (7 < changed_node[i] && changed_node[i] < 12) {
                            changed_node[i] = 46 - 4 * changed_node[i];
                        } else if (15 < changed_node[i] && changed_node[i] < 20) {
                            changed_node[i] = 77 - 4 * changed_node[i];
                        } else if (23 < changed_node[i] && changed_node[i] < 28) {
                            changed_node[i] = 108 - 4 * changed_node[i];
                        }
                    }
                }
            }
        }

        function isValidMove(x, y, color) {
            if (board[y][x] !== 0) return false;
            return flipPieces(x, y, color, true).length > 0;
        }

        function flipPieces(x, y, color, dryRun = false) {
            const directions = [[-1,-1], [-1,0], [-1,1], [0,-1], [0,1], [1,-1], [1,0], [1,1]];
            const flipped = [];

            for (const [dx, dy] of directions) {
                const line = [];
                let nx = x + dx;
                let ny = y + dy;

                while (nx >= 0 && nx < 4 && ny >= 0 && ny < 4 && board[ny][nx] !== 0) {
                    if (board[ny][nx] === color) {
                        flipped.push(...line);
                        break;
                    }
                    line.push({ x: nx, y: ny });
                    nx += dx;
                    ny += dy;
                }
            }

            if (!dryRun) {
                flipped.forEach(pos => board[pos.y][pos.x] = color);
            }

            return flipped;
        }

        function getValidMoves(color) {
            const moves = [];
            for (let y = 0; y < 4; y++) {
                for (let x = 0; x < 4; x++) {
                    if (isValidMove(x, y, color)) {
                        moves.push({ x, y });
                    }
                }
            }
            return moves;
        }

        function updateScore() {
            let playerScore = 0, aiScore = 0;
            
            for (let y = 0; y < 4; y++) {
                for (let x = 0; x < 4; x++) {
                    if (board[y][x] === 1) playerScore++;
                    if (board[y][x] === 2) aiScore++;
                }
            }

            document.getElementById('playerScore').textContent = playerScore;
            document.getElementById('aiScore').textContent = aiScore;
        }

        function updateMessage(message) {
            if (message.includes("パス") || message.includes("終局") || message.includes("エラー")) {
                document.getElementById('message').style.display = 'none';
                showCenterMessage(message);
            } else {
                document.getElementById('message').style.display = 'block';
                document.getElementById('message').textContent = message;
                document.getElementById('centerMessage').style.display = 'none';
            }
        }

        function showCenterMessage(message, duration = 2000) {
            const centerMessage = document.getElementById('centerMessage');
            centerMessage.textContent = message;
            centerMessage.style.display = 'block';
            
            if (duration > 0) {
                setTimeout(() => {
                    centerMessage.style.display = 'none';
                    if (message === "パス") {
                        document.getElementById('message').style.display = 'block';
                        if (currentPlayer === 0) {
                            document.getElementById('message').textContent = "あなたの番です";
                        } else {
                            document.getElementById('message').textContent = "おにぎりの番です";
                        }
                    }
                }, duration);
            }
        }

        function checkGameEnd() {
            const playerMoves = getValidMoves(1);
            const aiMoves = getValidMoves(2);
            
            if (playerMoves.length === 0 && aiMoves.length === 0) {
                endGame();
                return true;
            }
            return false;
        }

        function endGame() {
            gameState = 'gameOver';
            isAnimating = true;
            isGameEnding = true;
            hideValidMoves();

            setButtonsEnabled(false);

            if (lastMoveHighlight) {
                scene.remove(lastMoveHighlight);
                lastMoveHighlight = null;
            }

            document.getElementById('message').style.display = 'none';
            showCenterMessage("終局", 2000);

            setTimeout(() => {
                let playerScore = 0, aiScore = 0;
                let emptySpaces = 0;
                
                for (let y = 0; y < 4; y++) {
                    for (let x = 0; x < 4; x++) {
                        if (board[y][x] === 1) playerScore++;
                        else if (board[y][x] === 2) aiScore++;
                        else emptySpaces++;
                    }
                }

                if (playerScore > aiScore) {
                    playerScore += emptySpaces;
                } else if (aiScore > playerScore) {
                    aiScore += emptySpaces;
                } else {
                    playerScore += Math.floor(emptySpaces / 2);
                    aiScore += Math.ceil(emptySpaces / 2);
                }

                animateRemoveAllPieces(() => {
                    animateFinalPlacement(playerScore, aiScore);
                });
            }, 2000);
        }

        function animateRemoveAllPieces(callback) {
            const duration = 800;
            const startTime = Date.now();
            const pieces = [...boardPieces];

            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);

                pieces.forEach((piece, index) => {
                    const delay = index * 50;
                    const adjustedProgress = Math.max(0, Math.min(1, (elapsed - delay) / (duration - delay)));
                    
                    if (adjustedProgress > 0) {
                        const velocity = 8 * adjustedProgress;
                        const gravity = 12 * adjustedProgress * adjustedProgress;
                        piece.position.y = 0.25 + velocity - gravity;

                        piece.rotation.x += 0.2 * adjustedProgress;
                        piece.rotation.z += 0.15 * adjustedProgress;

                        if (piece.material) {
                            piece.material.opacity = 1 - adjustedProgress;
                            if (!piece.material.transparent) {
                                piece.material.transparent = true;
                            }
                        }
                    }
                });

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    boardPieces.forEach(piece => scene.remove(piece));
                    boardPieces = [];
                    callback();
                }
            }
            animate();
        }

        function animateFinalPlacement(finalPlayerScore, finalAiScore) {
            const whitePieces = [];
            const blackPieces = [];

            for (let y = 0; y < 4 && whitePieces.length < finalAiScore; y++) {
                for (let x = 0; x < 4 && whitePieces.length < finalAiScore; x++) {
                    whitePieces.push({ x, y });
                }
            }

            for (let y = 3; y >= 0 && blackPieces.length < finalPlayerScore; y--) {
                for (let x = 3; x >= 0 && blackPieces.length < finalPlayerScore; x--) {
                    blackPieces.push({ x, y });
                }
            }

            let totalPieces = finalPlayerScore + finalAiScore;
            let placedPieces = 0;

            whitePieces.forEach((pos, index) => {
                setTimeout(() => {
                    dropPieceWithBounce(pos.x, pos.y, 2, () => {
                        placedPieces++;
                        if (placedPieces === totalPieces) {
                            setTimeout(() => {
                                showGameResult(finalPlayerScore, finalAiScore);
                            }, 500);
                        }
                    });
                }, index * 100);
            });

            blackPieces.forEach((pos, index) => {
                setTimeout(() => {
                    dropPieceWithBounce(pos.x, pos.y, 1, () => {
                        placedPieces++;
                        if (placedPieces === totalPieces) {
                            setTimeout(() => {
                                showGameResult(finalPlayerScore, finalAiScore);
                            }, 500);
                        }
                    });
                }, index * 100);
            });
        }

        function dropPieceWithBounce(x, y, color, callback) {
            const geometry = createPieceGeometry();
            const material = new THREE.MeshLambertMaterial({ 
                vertexColors: true
            });
            const piece = new THREE.Mesh(geometry, material);
            
            const targetX = -1.875 + x * 1.25;
            const targetZ = -1.875 + y * 1.25;
            piece.position.set(targetX, 6, targetZ);
            
            if (color === 2) {
                piece.rotation.x = Math.PI;
            }
            
            piece.castShadow = true;
            scene.add(piece);
            boardPieces.push(piece);

            const duration = 800;
            const startTime = Date.now();
            const targetY = 0.25;
            const startY = 6;

            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);

                let bounceProgress;
                if (progress < 0.8) {
                    bounceProgress = progress / 0.8;
                    piece.position.y = startY + (targetY - startY) * bounceProgress * bounceProgress;
                } else {
                    const bouncePhase = (progress - 0.8) / 0.2;
                    const bounceHeight = 0.3 * (1 - bouncePhase);
                    const bounceOffset = Math.sin(bouncePhase * Math.PI * 3) * bounceHeight;
                    piece.position.y = targetY + bounceOffset;
                }

                piece.rotation.y = progress * Math.PI * 2;

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    piece.position.y = targetY;
                    piece.rotation.y = 0;
                    if (callback && typeof callback === 'function') {
                        callback();
                    }
                }
            }
            animate();
        }

        function showGameResult(finalPlayerScore, finalAiScore) {
            document.getElementById('finalPlayerScore').textContent = finalPlayerScore;
            document.getElementById('finalAiScore').textContent = finalAiScore;
            
            let result;
            if (finalPlayerScore > finalAiScore) {
                result = "あなたの勝ち🎉";
            } else if (finalAiScore > finalPlayerScore) {
                result = "おにぎりの勝ち🎉";
            } else {
                result = "引き分け";
            }
            
            document.getElementById('gameResult').textContent = result;
            document.getElementById('gameOverModal').style.display = 'flex';
            isAnimating = false;
            isGameEnding = false;            
        }

        function undoMove() {
            if (moveHistory.length === 0 || gameState !== 'playing' || isAnimating || isGameEnding) {
                return;
            }

            const myTurn = currentPlayer;
            const removedMoves = [];
            
            while (moveHistory.length > 0) {
                const lastMove = moveHistory[moveHistory.length - 1];
                const t = lastMove.color === 1 ? 0 : 1;
                
                removedMoves.push({ t, move: lastMove });
                moveHistory.pop();

                if (lastMove.x !== -1 && gameNotation.length > 0) {
                    gameNotation.pop();
                }
                
                if (t === myTurn) {
                    break;
                }
            }
            
            replayBoard();

            if (lastMoveHighlight) {
                scene.remove(lastMoveHighlight);
                lastMoveHighlight = null;
            }

            if (moveHistory.length > 0) {
                const lastMove = moveHistory[moveHistory.length - 1];
                if (lastMove.x !== -1) {
                    showLastMoveHighlight(lastMove.x, lastMove.y);
                }
            }
            
            updateBoard();
            updateScore();
            
            if (currentPlayer === 0 && getValidMoves(1).length > 0) {
                updateMessage("あなたの番です");
                showValidMoves();
                const actualPlayerMoves = moveHistory.filter(move => move.color === 1 && move.x !== -1).length;
                if (actualPlayerMoves === 0) {
                    setButtonsEnabled(false); 
                } else {
                    setButtonsEnabled(true);
                }
            } else if (currentPlayer === 1 && getValidMoves(2).length > 0) {
                updateMessage("おにぎりの番です");
                hideValidMoves();
                setTimeout(() => makeAIMove(), 1000);
            } else {
                if (checkGameEnd()) {
                    return;
                }
                updateMessage("手がありません");
            }
        }

        function startNewGame() {
            if (isGameEnding) {
                return; 
            }
            
            document.getElementById('gameOverModal').style.display = 'none';
            
            setButtonsEnabled(false);
            hideValidMoves();
            if (lastMoveHighlight) {
                scene.remove(lastMoveHighlight);
                lastMoveHighlight = null;
            }
 
            gameState = 'playing';
            currentPlayer = 0;
            moveHistory = [];
            gameNotation = [];
            white_node = 1;
            changed_node = [...node];
            isGameEnding = false;
            isAnimating = true; 

            updateMoveHistoryDisplay();
            
            if (boardPieces.length > 0) {
                animateRemoveAllPieces(() => {
                    board = [];
                    for (let y = 0; y < 4; y++) {
                        board[y] = [];
                        for (let x = 0; x < 4; x++) {
                            board[y][x] = 0;
                        }
                    }

                    const initialPositions = [
                        {x: 1, y: 1, color: 2}, 
                        {x: 2, y: 1, color: 1}, 
                        {x: 1, y: 2, color: 1}, 
                        {x: 2, y: 2, color: 2} 
                    ];
        
                    let placedPieces = 0;
                    let callbackExecuted = false;
                    
                    initialPositions.forEach((pos, index) => {
                        setTimeout(() => {
                            dropPieceWithBounce(pos.x, pos.y, pos.color, () => {
                                placedPieces++;
                                if (placedPieces === initialPositions.length && !callbackExecuted) {
                                    callbackExecuted = true;
                                    board[1][1] = 2;
                                    board[1][2] = 1;
                                    board[2][1] = 1;
                                    board[2][2] = 2;
                                    
                                    isAnimating = false;
                                    updateScore();
                                    updateMessage("あなたの番です");
                                    
                                    setTimeout(() => {
                                        showValidMoves();
                                    }, 300);
                                }
                            });
                        }, index * 150);
                    });
                });
            } else {
                initializeGame();
            }
        }

        function startGame() {
            document.getElementById('titleScreen').style.display = 'none';
            document.getElementById('gameContainer').style.display = 'block';
            
            initialAnimationDone = false;
            isAnimating = false;
            isGameEnding = false;
            setButtonsEnabled(false);

            initialAnimationDone = false;
            initializeGame();
        }
        function initializeGameAfterReset() {
            board = [];
            for (let y = 0; y < 4; y++) {
                board[y] = [];
                for (let x = 0; x < 4; x++) {
                    board[y][x] = 0;
                }
            }

            board[1][1] = 2;
            board[1][2] = 1;
            board[2][1] = 1;
            board[2][2] = 2;
            updateScore();
            updateMoveHistoryDisplay();
            updateMessage("あなたの番です");
            showValidMoves();

            setButtonsEnabled(true);
            document.getElementById('resetBtn').disabled = false;
        }

        function updateBoardPositions() {
            boardPieces.forEach((piece, index) => {
                let foundPosition = null;
                for (let y = 0; y < 4; y++) {
                    for (let x = 0; x < 4; x++) {
                        const expectedX = -1.875 + x * 1.25;
                        const expectedZ = -1.875 + y * 1.25;
                        if (Math.abs(piece.position.x - expectedX) < 0.1 && 
                            Math.abs(piece.position.z - expectedZ) < 0.1) {
                            foundPosition = { x, y };
                            break;
                        }
                    }
                    if (foundPosition) break;
                }

                if (foundPosition) {
                    piece.position.set(
                        -1.875 + foundPosition.x * 1.25,
                        0.25,
                        -1.875 + foundPosition.y * 1.25
                    );
                }
            });

            validMovesHighlights.forEach(highlight => {
            });

            if (lastMoveHighlight) {
                const lastMove = moveHistory[moveHistory.length - 1];
                if (lastMove && lastMove.x !== -1) {
                    lastMoveHighlight.position.set(
                        -1.875 + lastMove.x * 1.25,
                        0.16,
                        -1.875 + lastMove.y * 1.25
                    );
                }
            }
        }

        function recreateCoordinateLabels() {
            scene.children = scene.children.filter(child => {
                if (child.userData && child.userData.isCoordinateLabel) {
                    scene.remove(child);
                    return false;
                }
                return true;
            });

            createCoordinateLabels();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            adjustCameraForScreenSize();

            renderer.setSize(window.innerWidth, window.innerHeight);

            recreateCoordinateLabels();

            updateBoardPositions();
        }

        function animate() {
            requestAnimationFrame(animate);
            
            camera.position.x = Math.sin(Date.now() * 0.0005) * 0.1;
            camera.lookAt(0, 0, 0);
            validMovesHighlights.forEach(highlight => {
                highlight.material.opacity = 0.4 + Math.sin(Date.now() * 0.003) * 0.3;
            });

            renderer.render(scene, camera);
        }
        document.getElementById('startGameBtn').addEventListener('click', startGame);
        window.addEventListener('load', init);
    </script>
</body>
</html>